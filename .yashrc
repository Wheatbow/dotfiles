#!/bin/sh
#shellcheck disable=SC3043

local __git_prompt_sh
__git_prompt_sh="$TERMUX__PREFIX/etc/bash_completion.d/git-prompt.sh"

if [ -f "$__git_prompt_sh" ]; then
	#shellcheck source=/dev/null
	. "$__git_prompt_sh"
fi

export PS1
local __PS1__OS
__PS1__OS='\$'
if [ "$(uname -o)" = "GNU/Linux" ]; then
  __PS1__OS='!'
fi
PS1='${${?:/0/\\fg}/#[1-9]/\\fr}${$(pwd)/~/\~}$(__git_ps1)\n$__PS1__OS '

export YASH_AFTER_CD='ls -Ah --color=auto --group-directories-first'
_autocd() {
	if [ -d "$1" ]; then
		export HANDLED=true
  	cd -- "$@" || return
	fi
}
export COMMAND_NOT_FOUND_HANDLER='_autocd "$@"'

alias mkdir="mkdir -p"
alias rm="rm -Ir"
alias cp="cp -i"
alias mv="mv -i"
alias ls="ls -Ah --color=auto --group-directories-first"
alias du="du -h"
alias df="df -h"
alias mem="free -m"
alias pcpu='ps uf -u "$(whoami)" --sort=-pcpu'
alias pmem='ps uf -u "$(whoami)" --sort=-pmem'
alias pi='pkg install'
alias pu='pkg update; pkg upgrade'
alias pr='pkg uninstall'
alias pq='pkg search'
alias pc='pkg clean'
alias pl='pkg list-installed'
alias xi='xbps-install'
alias xu='xbps-install -Su'
alias xr='xbps-remove'
alias xq='xbps-query -Rs'
alias xc='xbps-remove --clean-cache'
alias xl='xbps-query -l'
alias ga="git add"
alias gmv="git mv"
alias grm="git remove"
alias gu="git restore"
alias gc="git commit"
alias gp="git push"
alias gd="git diff"
alias gl="git log --reverse"
alias gs="git status"
alias gb="git branch"
alias gco="git checkout"
alias gf="git fetch"
alias gm="git merge"
alias gfm="git pull"
alias v="vault"
alias ve="vault --edit"
alias t="task"

disk() {
	if [ -d "/storage/emulated" ]; then
		df "/storage/emulated"
	else
	  df "/"
	fi
}

wm() {
	local dpi
	dpi="$1"
	if [ -z "$dpi" ]; then
		dpi="168"
	fi
  local cursor_size
  cursor_size="32"
  if [ "$dpi" -gt 192 ]; then
  	cursor_size="48"
  elif [ "$dpi" -gt 288 ]; then
    cursor_size="64"
  fi
  printf "Xft.dpi: %s\nXcursor.size: %s\n" "$dpi" "$cursor_size" >| "$HOME/.Xdpi"
  termux-x11 :0 -xstartup "dbus-launch --exit-with-session i3" -dpi "$dpi" 1> /dev/null 2>&1
}

_basename() {
	local separator
	separator="/"
	for option in "$@"; do
		if [ "${option}" != "${option#-}" ]; then
			case "$option" in
				-u|--unix)
					separator="/"
					;;
				-w|--windows)
					separator="\\"
					;;
				*)
					printf "basename %s: invalid option" "$option"
					return 1
			esac
			shift
		fi
	done
	if [ -z "$1" ]; then
		printf "basename: missing operand\n"
		return 1
	fi
	for in in "$@"; do
		while true; do
			local head
			head="${in%"$separator"*}"
			local tail
			tail="${in#"$head"}"
			if [ "$tail" != "$separator" ]; then
				if [ -n "$tail" ]; then
					printf "%s\n" "${tail#"$separator"}"
				else
					printf "%s\n" "$head"
				fi
				break
			elif [ -z "$head" ]; then
				printf "%s\n" "$tail"
				break
			fi
			in="$head"
		done
	done
}

_dirname() {
	local separator
	separator="/"
		for option in "$@"; do
		if [ "${option}" != "${option#-}" ]; then
			case "$option" in
				-u|--unix)
					separator="/"
					;;
				-w|--windows)
					separator="\\"
					;;
				*)
					printf "dirname %s: invalid option" "$option"
					return 1
			esac
			shift
		fi
	done
	if [ -z "$1" ]; then
		printf "dirname: missing operand\n"
		return 1
	fi
	for in in "$@"; do
		while true; do
			local head
			head="${in%"$separator"*}"
			local tail
			tail="${in#"$head"}"
			if [ "$tail" != "$separator" ]; then
				if [ -z "$tail" ]; then
					printf ".\n"
				else
					in="$head"
					while true; do
						head="${in%"$separator"*}"
						tail="${in#"$head"}"
						if [ "$tail" != "$separator" ]; then
							printf "%s\n" "$head$tail"
							break
						fi
						in="$head"
					done
					break
				fi
				break
			elif [ -z "$head" ]; then
				printf "%s\n" "$tail"
				break
			fi
			in="$head"
		done
	done
}

_realpath() {
	if [ "$#" -eq 0 ]; then
		printf "realpath: missing operand\n"
		return 1
	fi
	for in in "$@"; do
		local out
		local component
		component="${in%/"${in#*/}"}"
		if [ -n "$component" ]; then
			out="$(pwd)"
		else
			out=
  	fi
		while true; do
			if [ -n "$component" ] && [ "$component" != '.' ]; then
				if [ "$component" = '..' ]; then
					out="${out%/*}"
				else
					out="$out/$component"
				fi
			fi
			in="${in#*/}"
			if [ "$in" = "$component" ]; then
				if [ -n "$out" ]; then
					printf "%s\n" "$out"
				else
					printf "/\n"
				fi
				break
			fi
			component="${in%/"${in#*/}"}"
		done
	done
}

_random() {
  hexdump -e '"%02x" 8 ""' -n 8 /dev/random
}

_mktemp() {
	local directory
	directory=0
	for option in "$@"; do
		if [ "$option" != "${option#-}" ]; then
			case "$option" in
				-d|--directory)
					directory=1
				  ;;
				*)
				  printf "mktemp %s: invalid option\n" "$option"
					return 1
			esac
			shift
		fi
	done
	local prefix
	if [ -z "$1" ]; then
		prefix="tmp-"
	else
		prefix="$1"
	fi
	local target
	while true; do
		target="$TMPDIR/$prefix$(_random)"
		if ! [ -e "$target" ]; then
			break
		fi
	done
	if [ "$directory" -eq 0 ]; then
		true > "$target"
	else
		mkdir "$target"
	fi
	printf "%s\n" "$target"
}

_checkdepends() {
	local message
	message="$1"
	shift
	for i in "$@"; do
		if ! command -v "$i" 1> /dev/null; then
			# shellcheck disable=SC2059
			printf "$message" "$i"
			return 1
		fi
	done
}

up() {
	local path
	path="."
	if [ -n "$1" ]; then
		path="$1"
	elif [ -n "$VAULT_PATH" ]; then
	  path="$VAULT_PATH"
	fi
  local message
  message="$2"
  {
    flock -s 3
		if [ -n "$(git -C "$path" status --porcelain)" ]; then
			git -C "$path" add --all || return
		fi
  } 3> "$path/.lock"
	printf "Committing changes...\n"
	git -C "$path" commit --allow-empty-message --no-edit -m "$message" || return
	printf "Pushing changes...\n"
  git -C "$path" push || return
}

vault() {
	if ! _checkdepends "vault: needs %s to run\n" "hexdump" "tar" "age" "inotifywait" "git" "rsync" "flock"; then
		return 1
	fi
	local command
	command="shell"
	for option in "$@"; do
		if [ "$option" != "${option#-}" ]; then
			case "$option" in
				--init)
					command="init"
				;;
				-e|--edit)
					command="edit"
				;;
				*)
					printf "vault %s: unrecognized option\n" "$option"
					return 1
			esac
			shift
		fi
	done
	if [ -z "$1" ]; then
		printf "vault: missing path\n"
		return 1
	fi
	local path
	path="$(_realpath "$1")"
	shift
	case "$command" in
		init)
			if [ -e "$path" ]; then
				printf "vault %s create: file or directory already exist\n" "$path"
				return 1
			fi
			temp="$(_mktemp -d "vault-")"
			trap 'rm -rf "$temp"' EXIT
			local identity
			IFS="" identity="$(age-keygen 2> /dev/null)"
			local recipient
			recipient="$(echo "$identity" | age-keygen -y)"
			printf "Choose a password for protecting your files.\n"
			if ! echo "$identity" | age -e -p -o "$temp/identity.age"; then
				rm -rf "$temp"
				return 1
			fi
			unset identity
			mkdir -p "$temp/protected/content"
			echo "$recipient" > "$temp/protected/recipient"
			echo "0" > "$temp/protected/version"
			tar -c --zstd -C "$temp/protected" . | age -e -r "$recipient" -o "$temp/protected.age"
			mkdir -p "$path"
			cp "$temp/identity.age" "$temp/protected.age" "$path"
			_basename "$temp" > "$path/.id"
			echo "$temp"
			rm -rf "$temp"
			git -C "$path" init
			;;
		shell|edit)
			if [ ! -d "$path" ]; then
				printf "vault %s %s: no such directory\n" "$path" "$command"
				return 1
			elif [ ! -f "$path/identity.age" ]; then
				printf "vault %s %s: missing identity.age\n" "$path" "$command"
				return 1
			elif [ ! -f "$path/protected.age" ]; then
				printf "vault %s %s: missing protected.age\n" "$path" "$command"
				return 1
			elif [ ! -f "$path/.id" ]; then
				printf "vault %s %s: missing .id\n" "$path" "$command"
				return 1
			fi
	    local id
		  read -r id < "$path/.id"
		  local temp
		  temp="$TMPDIR/$id"
		  local server
		  server=false
		  if ! [ -d "$temp" ]; then
				server=true
			fi
		  local pid
		  if "$server"; then
		  	mkdir -p "$temp"
				trap 'rm -rf "$temp"' EXIT
				mkdir "$temp/protected"
				if ! age -d -i "$path/identity.age" "$path/protected.age" | tar -x --zstd -C "$temp/protected"; then
					rm -rf "$temp"
					return 1
				fi
		  	cp -axr "$temp/protected" "$temp/protected.copy"
		  	local pipe
		  	pipe="$temp/pipe"
				mkfifo "$pipe"
				{ inotifywait -m -q -r -e create -e delete -e modify -e move -o "$pipe" "$temp/protected" & } 2>/dev/null
				pid="$!"
				{
					{ while read -r _event; do
				  		{
				    		flock -x 3
				  	  	rsync -qaxr --delete "$temp/protected/" "$temp/protected.copy"
								tar -c --zstd -C "$temp/protected.copy" . | age -e -R "$temp/protected.copy/recipient" -o "$path/protected.age"
				  		} 3> "$path/.lock"
			  		done < "$pipe"
					} &
		  	} 2>/dev/null
		  fi
			case "$command" in
			  edit)
			  	"$EDITOR" "$temp/protected/content"
			  ;;
				shell)
					VAULT_PATH="$path" TASKRC="$temp/protected/taskrc" TASKDATA="$temp/protected/.task" yash -c "cd $temp/protected/content;$SHELL"
				;;
			esac
		  if "$server"; then
				kill "$pid"
				wait 1> /dev/null
				rm -rf "$temp"
			fi
			up "$path"
			;;
		*)
			printf "vault %s %s: invalid command\n" "$path" "$command"
			return 1
	esac
}
